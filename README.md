# Course Overview

### General Overview

Spring Integration: Using Channel Adapters to Integrate with External Systems. Spring Integration is Spring's implementation of the enterprise integration patterns and provides powerful functionality for integrating different components across your environment. In this project, we're going to review how to integrate with different external systems. Some of the major topics that we'll cover include integrating with message brokers, such as ActiveMQ, RabbitMQ, and Apache Kafka. integrating with databases, such as MariaDB and MongoDB, invoking RESTful web services from a Spring Integration application, and building custom integrations for which Spring Integration does not provide native support. By the end of this project, you'll understand how to integrate with several specific external systems. But more importantly, you'll understand Spring Integrations model for integrating with external systems so that you'll be able to integrate with any system in your environment. Before beginning this project, you should be familiar with the basics of Spring, Spring Boot, and Spring Integration, including messages and channels and how they work together to solve enterprise integration problems. I hope you'll learn how to use Spring Integration to integrate different external systems with the Spring Integration: Using Channel Adapters to Integrate with External Systems course at Pluralsight.

# Integrating with Message Brokers

### Version Check

### Introduction

Welcome to the module, Integrating with Message Brokers in this Spring Integration: Using Channel Adapters to Integrate with External Systems course. In this course, we're going to review channel adapters to see how we can send messages to and receive messages from external systems. In this module we're going to focus on what is probably the most important integration, namely message brokers. We'll begin with an overview of channel adapters and see how they work. And then we'll explore how to integrate with two specific brokers, both using its own protocol. We'll start with RabbitMQ, which has quickly become one of the most popular open‑source message brokers and uses the AMQP protocol. And then we'll look at ActiveMQ, which uses the JMS APIs. A channel adaptor is a message endpoint that enables connecting a single sender or receiver to a message channel. Channel adapters come in four flavors. Inbound channel adapters are used for one‑way integration to bring data into the messaging application. Outbound channel adapters are used for one‑way integration to send data out of the messaging application. Inbound gateways are used for bidirectional integration flow, where some other system invokes the messaging application and receives a reply. And outbound gateways are used for a bidirectional integration flow, where the messaging application invokes some external service or entity and expects a result. We'll explore how to use each type of channel adaptor with our two brokers. In order to avoid having to download and install each of these message brokers in order to follow along with this module, I've opted to run the message brokers in Docker containers using pre‑configured and publicly available images that you can run on your own computer. The prerequisite, therefore, is that you need to install Docker Desktop on your computer. You can download Docker Desktop for free on their website. They have clients for Windows, Mac, and Linux. The only caveat that I've encountered is that in order to run Docker on Windows 10, you need to be running Windows 10 Pro. Alternatively, you can run Docker containers on AWS, Azure, or Google Cloud, or you can simply install the message broker directly on your local computer. So let's get started by integrating Spring Integration with RabbitMQ.

### RabbitMQ (AMQP) Channel Adapters

In this section, we're going to review RabbitMQ and performing an integration using the AMQP support in Spring Integration. RabbitMQ uses the Advanced Message Queueing Protocol, or AMQP. AMQP is an open standard for passing business messages between applications or organizations. In other words, it's a platform‑independent protocol that connects disparate systems. It uses a binary protocol that can be used by different programming languages on different platforms. AMQP works as follows. A producer publishes a message to an exchange inside the AMQP broker. AMQP does not support standard Spring Integration messages, so the AMQP library creates a message abstraction that ultimately sends a byte array to the exchange. The exchange is responsible for routing messages with links and routing keys to various queues. A queue is a buffer that stores messages, and consumers receive messages from queues. As I mentioned in the previous section, we receive messages from a message broker through an inbound channel, and we send messages to a broker using an output channel. To integrate with AMQP, the AmqpOutboundChannelAdapter provides inbound channel adaptor capabilities, and the AmqpOutboundEndpoint provides outbound channel adaptor capabilities. Let's review how to create an inbound channel adapter that works with AMQP. First, we create a MessageChannel to which messages should be delivered. Next, we create a simple MessageListenerContainer that accepts as input a ConnectionFactory, which will be created when Spring finds RabbitMQ in the class path. The container handles the active responsibilities so that listeners can remain passive. It uses the provided ConnectionFactory to connect to RabbitMQ and listen for messages on the specified queue. Finally, the AmqpInboundChannelAdapter creates an inbound channel adapter using the message listenerContainer and publishes messages that it receives to the specified output channel. Now let's review how to create an outbound channel adapter. We begin by creating a MessageChannel to which our application will publish messages that should be sent to RabbitMQ. Next, we create the queue to which we want to publish our messages. And finally we create an AmqpOutboundEndpoint that is invoked when a message is published to the amqpOutboundChannel, The AmqpOutboundEndpoint is configured with an amqpTemplate, which Spring will automatically create for us when it finds RabbitMQ in our class path, and we specify the queue name to which we want to publish our messages as the AmqpOutboundEndpoint's routing key. When the AMQP exchange receives the message, it will use this routing key to route the message to the specified queue name. For our example, we're going to integrate the foo reservation system into the Globomantics conference registration system. When a user books a reservation in the foo reservation system, it will publish a message to the foo reservation queue in RabbitMQ and will handle that message to register the user for a particular conference. The code example we'll look at runs in two different JVMs. The foo reservation publisher application defines a FoodReservationService that publishes a foo reservation to an AmqpOutboundEndpoint that sends it to the RabbitMQ exchange that routes it to the foo reservation queue. The Globomantics reservation service defines an AmqpInboundChannelAdapter that listens for messages on that queue and publishes his messages to the foo reservation listener. In order to run the example application, you're going to need a RabbitMQ instance to connect to. You can download and install RabbitMQ, or you can run it inside a Docker container. I've tested the example application using the official RabbitMQ Docker image, so if you've installed Docker Desktop on your computer, you can run it with this command. The official RabbitMQ Docker image is rabbitmq:3, where rabbitmq is the name of the image and 3 is the version. I opted to run 3‑management so that we can access the RabbitMQ web interface on port 15672. The default username is guest, and the default password is guest. For more configuration options, see the RabbitMQ DockerHub page. But this configuration is a simple way to get a RabbitMQ instance up and running in your local Docker environment. Let's dive into the code and see this in action. We'll begin by building two applications, the foo reservation publisher, which will use an AmqpOutboundEndpoint to publish foo reservations to RabbitMQ, and the Globomantics Registration Service, which will use an AmqpInboundChannelAdapter to receive and process those messages. Then we'll start both applications, publish foo reservations to RabbitMQ, and validate that the Globomantics Registration Service receives those messages. The RabbitMQ config class is a Spring Configuration class. It creates a DirectChannel named reservationChannel and then an ObjectToJsonTransformer that receives messages from the reservationChannel and publishes messages to the amqpOutboundChannel. Because AMQP uses a binary protocol, we can only send serializable objects to it, and a JSON string is a good candidate, especially for interoperability with other systems. We then create another DirectChannel named amqpOutboundChannel that is used by a ServiceActivator to invoke our AMQP outbound bean. This bean creates an AmqpOutboundEndpoint and sets its routing key to the name of the queue to which we want to publish the message, which in this case, is foo‑reservation‑queue. When the RabbitMQ exchange receives the message and sees this routing key, it will know to publish the message to the queue with the same name. Finally, we could go into RabbitMQ and create the queue manually, but instead we create a new queue bean with the name of the queue that we want to create. This will cause Spring to create the queue in RabbitMQ for us. The foo reservation gateway is a messaging gateway that publishes messages to the reservationChannel. It defines a single method, publishReservation, that accepts a fooReservation and publishes it to the reservationChannel. A FooReservation is a plain old Java object that has an id and a name. The FooReservationService is a Spring service that publishes foo reservations to the FooReservation gateway through its publishReservation method. The RabbitMQ example application is a command‑line Spring Boot application with the FooReservation service wired into it that creates six reservations and publishes them to the FoodReservationService with a 2‑second delay. This is the application that will publish our reservations. So now let's look at the application that will receive the reservations. The RabbitMQ inbound config is a Spring Configuration class. It creates a new DirectChannel named fooReservationListenerChannel and then and AmqpInboundChannelAdapter that sends messages to that channel. It's configured with a simple message listenerContainer that accepts a connectionFactory, which Spring will create for us when it sees RabbitMQ in our class path and sets the name of the queue on which to listen. This is all that you need to do to listen for messages on a RabbitMQ queue and publish those messages to a channel. We also create the same channel that we did in the previous application. This is only required if the queue does not already exist. But if we start our listener application before starting our publishing application and the queue does not exist, then the application will fail to start. And don't worry, as long as the names match, it will not create a new queue. The fooReservationListener is a Spring service with a ServiceActivator that receives messages from the fooReservationListenerChannel and invokes the handleMessage method. At this point, we're just going to log the payload of the message that we receive. Finally, the RabbitMQ example application is a command line Spring Boot application. Spring will find our configuration component in the fooReservationListener service in its component scan and start listening for messages. Let's start the listening application and the publishing application. We can see from the logs that it publishes six messages, and in the listener application we can see those messages bean received.

### RabbitMQ (AMQP) Gateways

Now let's look at how we can build inbound and outbound gateways for RabbitMQ. Recall that inbound gateways allow you to receive a message and return a response. And outbound gateways allow you to send a message and receive a response. To Integrate with AMQP, the AmqpInboundGateway provides inbound gateway capabilities. And the AmqpOutboundEndpoint, which we saw in the last section, provides outbound gateway capabilities with one small modification, namely, telling it that we expect a response. In order to create an inbound gateway, we first create a new channel. Then we create a SimpleMessageListenerContainer, as we did in the previous section. Recall that the container handles the active responsibilities of interacting with RabbitMQ so that listeners can remain passive. It uses the provided ConnectionFactory to connect to RabbitMQ and listen for messages on the specified queue. Finally, we create an AmqpInboundGateway, setting the request channel to the channel we just created and providing it with the name of a reply channel. Spring Integration will provide the reply queue configuration to route the message back to the sender. Creating the outbound gateway is almost identical to creating the outbound channel adaptor. We create a channel and an outbound endpoint, but this time we set the AMQP outbound endpoint's expectReply setting to true this way, the outbound endpoint will wait for a response to the message that it's sending. Finally, we create a MessagingGateway that publishes a message to our channel when the getAddress method is called. It accepts a Long, which is the userId, and returns the response from the AMQP call as a message. Here's our example, which is in addition to the example in the previous section. After the foo reservation service publishes a reservation to our FooReservationListener through a RabbitMQ queue, the FooReservationListener requests the address of the user in the reservation. The idea is that while the foo reservation service publishes information about the reservation, the Globomantics Registration Service needs more information, namely the user's address. So it publishes a message requesting the address to the AmqpOutboundEndpoint through the foo address channel. The outbound endpoint publishes a message to Rabbit MQ's exchange with a routing key of getAddress, which is routed to the getAddress queue. The AmqpInboundGateway receives the message, invokes the AddressService to retrieve the address, and returns it back to us. So let's take a look at the code and run it to see the message exchange between the two Java processes. I updated the listener app by adding a new Spring configuration class named RabbitMQOutboundGatewayConfig. This class defines a new mMessageChannel named fooAddressChannel and then creates an AmqpOutboundEndpoint that is invoked by a ServiceActivator when a message is published to the foo address channel. It accepts an amqpTemplate, which again is created automatically when Spring finds RabbitMQ in our class path, and it creates the AmqpOutboundEndpoint with that template. We then set ExpectReply to true, which is the difference between using the endpoint as an outbound gateway rather than as an outbound channel adaptor. We set the routing key to the name of the address queue, and then we create a new MessagingGateway that will publish messages to the foo address channel when its getAddress method is called. Notice that it will return a message. This message will contain the response from the foo reservation publisher application. Next, the FooReservationListener wires in the addressGateway, and when it receives a new reservation, it makes a call to the addressGateway to retrieve the address for this user and prints it out to the logs. Switching over to the foo reservation publisher application, I added a new Spring configuration class named FooAddressConfig that creates a new MessageChannel to handle address requests and then creates an AmqpInboundGateway bean. Just as before, we create a SimpleMessageListenerContainer that listens for messages, but this time on the address queue. The AmqpInboundGateway is configured to use that SimpleMessageListenerContainer and publish the messages that it receives to the RequestChannel, which in this case is the getAddressInputChannel. It sets the DefaultReplyTo to a new get address reply queue, and Spring Integration will see this and route the response back to our client. Finally, we create a new get address queue, which will cause the creation of the queue in Rabbit MQ. The AddressService is a Spring service with a ServiceActivator listening for messages on the getAddressInputChannel that simply returns the string, this is my address. In practice, we'd probably take the reservation ID, look up the reservation in our database, and return the corresponding address. But the point of this exercise is to get the communication pathways working. So let's run both applications and see the new gateway callback from the reservation listener to the reservation publisher. If we look at the reservation publisher logs we can see each reservation being published, followed by a request for an address. And in the reservation listener logs, we see that the reservation is received and we see the "this is my address" response. In this section, we reviewed AMQP and integrating a Spring Integration application with RabbitMQ. First, we saw how the AmqpInboundChannelAdapter is used to implement an inbound channel adaptor and receive messages that are published to a RabbitMQ queue. Then we reviewed the AmqpOutboundEndpoint, which can be used as both an outbound channel adapter to publish a message to a RabbitMQ queue and as an outbound gateway, which can be used to send a message to RabbitMQ and receive a response. The only difference between the two uses is that we set the ExpectReply value to true when using it as an outbound gateway. Finally, we discussed the AmqpInboundGateway, which is an inbound gateway that receives messages published to a queue and returns a response. Next up, we're going to review integrating with ActiveMQ using Spring Integration's JMS support.

### ActiveMQ (JMS) Channel Adapters

In this section, we're going to review ActiveMQ in performing an integration using the JMS support in Spring integration. The definition of JMS from Oracle's website is, "a messaging standard that allows application components based on the Java Platform Enterprise Edition (Java EE) to create, send, receive, and read messages. It enables distributed communication that is loosely coupled, reliable, and asynchronous." We looked at AMQP already, so you might be curious about the differences between AMQP and JMS. The main difference is that AMQP is a binary wire‑level protocol used for integrating different systems that are potentially built on different technology stacks, whereas JMS is a Java API that abstracts Java programs from the underlying complexities of communicating with the JMS provider, much like JDBC does for databases. Let's begin by looking at sending messages to and receiving messages from ActiveMQ using inbound and outbound channel adapters. Inbound requests are handled using the JmsMessageDrivenEndpoint, which subscribes to a queue and publishes messages that it receives to a channel asynchronously. Outbound messages are published using the JmsSendingMessageHandler, which will be triggered by a service activator when a message is published to a channel. In order to create an inbound channel adaptor, we create three beans. First, we create a SimpleMessageListenerContainer, as we did in the last section. The container accepts a ConnectionFactory, which Spring will create when it sees ActiveMQ in the class path. We then create the SimpleMessageListenerContainer, set its ConnectionFactory, and set the destination queue name that we want to listen on. Again, the SimpleMessage listenerContainer does the underlying work of subscribing to the queue and managing the interactions with the JMS broker. Next, we create a ChannelPublishingJmsMessageListener. This is a JmsMessageListener that converts a JMS message into a Spring integration message and sends that message to a channel. Finally, we create a JmsMessageDrivenEndpoint. The endpoint uses the listener container to listen for messages published to the queue, convert them to Spring integration messages using the ChannelPublishingJmsMessageListener, and then publishes them to the specified output channel. In order to publish a message to ActiveMQ, we create a new channel and then create a MessageHandler Bean that is triggered by a ServiceActivator when a message is published to that channel. The jmsMessageHandler Bean accepts a JmsTemplate, which will be automatically created by Spring when it sees ActiveMQ in the class path. It creates a JmsSendingMessage handler with the JmsTemplate and then sets the destination queue name to which to publish messages. Finally, we create a MessagingGateway that our application can use to publish a message to the publishing channel. This example is going to be the same as the example in the last section, namely another reservation system, the bar reservation system, is going to publish reservations to ActiveMQ, and we're going to handle them. The bar reservation service will publish a bar reservation to a reservation channel that will be published to ActiveMQ through a. JMS sending message handler. The reservation will be published to a queue and received by a JMS message driven endpoint, which will publish it to a channel to be handled by the bar reservation listener. Just as we did in the last section, we're going to run ActiveMQ in a Docker container. ActiveMQ has two major releases; the classic version, which uses JMS, and Artemis, which uses AMQP. Because we're viewing Spring integration's JMS support, I opted to use the classic version. The rmohr/activemq Docker image has over 10 million downloads and is one of the most popular ActiveMQ images. We expose 2 ports; 61616 is the standard port that JMS clients will connect to, and 8161, which is the port to the HTTP management console. You can start it with this command. With ActiveMQ running, let's take a look at the code and see this in action. Let's look at the configuration for our inbound channel adapter. The ActiveMQInboundConfig class is a Spring configuration class. It defines our destination queue name as reservation‑queue. It creates a reservationConsumerChannel, which is the channel to which messages publish to an ActiveMQ queue will be delivered. Our goal is to subscribe to a queue, and when a message is published to that queue to publish a message to a channel to be handled by one of our components. To do this, we create a simpleMessageListenerContainer with a ConnectionFactory that Spring automatically creates when it sees ActiveMQ in our class path and then set its destination queue name. We create a ChannelPublishingJmsMessage listener that converts a JMS message into a Spring integration message. And then we create a JmsMessageDrivenEndpoint that uses both the simpleMessageListenerContainer to receive messages and the channelPublishingJmsMessageListener to convert JMS messages to Spring integration messages, and then to publish the message to the reservationConsumerChannel. The BarReservationListener is a Spring service that defines a handleMessage method with a ServiceActivator that listens for messages on the reservationConsumerChannel. As we'll see shortly, the BarReservationService will be publishing a BarReservation as a JSON string, so we use the Jackson objectMapper to convert the string that we receive into a BarReservation object and log it. A BarReservation is a plain old Java object with two fields, an ID and a name. Now let's look at the publisher. The ActiveMQOutboundConfig class defines the same queue name, reservation‑queue, and then creates two channels. The first channel, reservationChannel, is the channel to which the BarReservationService will publish its reservations. It's delivered to the ObjectToJsonTransformer Bean, which converts the reservation object to a JSON string. The second channel, publishReservationToActiveMQ, is the channel to which our transformer publishes the JSON string. The jmsMessageHandler receives the message using the ServiceActivator and publishes it to the destination queue specified by its name. Finally, the BarReservationGateway is a messaging gateway that publishes a BarReservation to the ReservationChannel. The BarReservationService is a Spring service with the BarReservationGateway wired into it that publishes a BarReservation to the ReservationChannel through the gateway. The ActiveMQSampleApplication is a command‑line Spring boot application with the BarReservationService wired into it that publishes six reservations to ActiveMQ through the BarReservationService with a 2‑second delay. Let's run the application and review the logs. In the logs, we can see the BarReservationService publishing each of its six reservations, and then we can see that the BarReservationListener receives each reservation.

### ActiveMQ (JMS) Gateways

Now let's take a look at implementing inbound and outbound gateways for ActiveMQ. Building inbound and outbound gateways for JMS providers is accomplished using the JmsInboundGateway and the JmsOutboundGateway classes. Creating a JmsInboundGateway is similar to how we built our JMS message driven endpoint in the previous video, We, first, create a SimpleMessageListenerContainer which manages the connection to ActiveMQ and subscribes to the specified destination QUEUE_NAME. Then we create a ChannelPublishingJmsMessageListener which converts JMS messages into spring integration messages, but this time we set it's ExpectReply property to true, which means that we expect the request channel to return a response that we will send back to our caller. Finally, we create a . JmsInboundGateway that uses the container and listener and we set the request channel to the channel that will handle the request and return a response. For the outbound gateway, we create a JmsOutboundGateway and configure it. We set the ActiveMQ ConnectionFactory, which spring creates for us when it sees ActiveMQ in the class path. Then we set the destination queue name and the reply destination queue name. Finally, we specify the channel to which to send the reply. The outbound gateway is triggered by a service activator listening for messages published to the getAddressChannel. We create a MessagingGateway that our service can use to publish messages to the getAddressChannel, but this time we specify that the channel will receive the reply, namely the getAddressReplyChannel. For this example, we're going to do the same thing that we did with RabbitMQ, namely, we're going to request the address of the user in the reservation. The bar service publishes a reservation to ActiveMQ that was received by the bar reservation listener through a JMS message driven endpoint. Now we're going to use a JMS Outbound Gateway to publish a new message requesting the address to the GetAddress queue that will be received by a JmsInboundGateway and handled by the address service. The address service will publish the response back to a reply queue that will be delivered back to our Bar Reservation Listener by the JmsOutboundGateway. Let's take a look at the code and see this in action. Let's start by looking at the outbound gateway. The ActiveMQOutboundGateway configuration class creates two channels. The getAddressChannel is used to trigger the outbound gateway and send an address requests to ActiveMQ and the getAddressReplyChannel is used to receive the response from ActiveMQ. We create a JmsOutboundGateway, pass it the ActiveMQ connection factory that Spring configures for us when it finds ActiveMQ in our class path, and then we set the request destination queue name and the reply destination queue name. Finally, we set the ReplyChannel to the getAddressReplyChannel. We create an AddressGateway that publishes messages to the getAddressChannel which triggers our outbound gateway service activator and waits for a reply from the getAddressReplyChannel, which is the channel that the outbound gateway publishes its responses to, We update the BarReservationListener to autowire in our gateway, and when we receive a reservation message, we invoke the address gateway's getAddress method with the reservations user ID to retrieve the address. The address is returned as a Json string representation of a bar address so we use a Jackson objectMapper to deserialize it and log it. A bar address is a plain old Java object that manages four fields, the address, city, state, and zipcode. At this point, we have published the request to ActiveMQ, now let's review how we handle it. The ActiveMQInboundGateway configuration class creates a getAddressInboundGatewayChannel, which will be used to send requests to an address service. The JmsInboundGateway is created using both a SimpleMessageListenerContainer that listens for messages on the getAddress queue and a ChannelPublishingJmsMessageListener which converts JMS messages into Spring integration messages. Note that we set its ExpectReply property to true denoting that we expect the request channel to return a reply. The JmsInboundGateway accepts both the SimpleMessageListenerContainer and the ChannelPublishingJmsMessageListener in its constructor and then we set the RequestChannel to which we want to send the message. The address service is a spring service with a ServiceActivator that listens for messages on the getAddressInboundGatewayChannel. It receives a message with the user ID as its payload and then returns a new JSON string representation of a BarAddress using a Jackson objectMapper. Let's run the code and review the logs. As you can see in the logs, the BarReservation service publishes a reservation, which is received by the bar ReservationListener that then sends a request for the user's address. The address service receives the message, returns a bar address that the bar reservation listener then logs and it does this for all six reservations. In this section, we reviewed how to integrate ActiveMQ with spring integration. We saw that the JmsMessageDrivenEndpoint served as an asynchronous inbound channel adapter that the JmsSendingMessageHandler served as an outbound channel adapter that the JmsInboundGateway is used as an inbound gateway, and the JmsOutboundGateway is used as an outbound gateway.

### Conclusion

In this section, we reviewed how Spring Integration works with message brokers. First we saw that a channel adapter is a message endpoint that enables connecting a single sender or receiver to a message channel. Channel adapters come in four types. An inbound channel adapter allows us to receive a message from a message broker. An outbound channel adapter allows us to send a message to a message broker. An inbound gateway allows us to receive a message from a message broker and return a response. And an outbound gateway allows us to send a message to a message broker and receive a response. We reviewed how to integrate with two different message brokers. First we reviewed RabbitMQ and saw how to integrate with the message broker using the AMQP protocol. And then we reviewed ActiveMQ and saw how to integrate with a message broker using the JMS API. At this point, you should understand the roles of inbound and outbound channel adapters and gateways and how to use them. You should understand specifically how to integrate with RabbitMQ and ActiveMQ, but more importantly, you should understand the Spring Integration model for integrating with different AMQP and JMS providers. In the next module, we're going to review how to use Spring Integration to integrate with Apache Kafka.

# Integrating with Apache Kafka

### Introduction

Welcome to the module, Integrating with Apache Kafka in the Using Channel Adapters to Integrate with External Systems course. We're going to review what Apache Kafka is and the business problem that it solves. Then we're going to see how Kafka implements inbound and outbound channel adapters. And finally, we're going to explore Kafka support for inbound and outbound gateways. Apache Kafka is a publish‑subscribe based, durable, distributed, streaming platform. Now that's a bit of a mouthful, so let's break this definition down. Kafka is based off of publish‑subscribe messaging, meaning that a message published to a topic can be consumed by multiple subscribers. It's durable, meaning that it saves messages that it receives in a log so that messages are not lost and any new consumer can connect and catch up by requesting older messages. It's distributed, meaning that you're able to run multiple Kafka brokers even across a data center, and those brokers replicate their messages following a leader‑follower pattern. And finally, Kafka is a streaming platform. It was originally designed to handle user interactions with websites, things like logins and page clicks. So it scales very well and it's events can be handled by consumers through a streaming API or a poll‑based consumer API so that events arrive to consumers in order until there are no remaining events to process. The Apache Kafka documentation defines two core use cases for Kafka. First, it supports real‑time streaming data pipelines to reliably get data between systems or applications. And second, it supports real‑time streaming applications that transform or react to streams of data. And more recently, it's been used as a replacement for traditional message brokers because of its performance and its reliability. At a high level, an Apache Kafka cluster consists of one or more brokers that are managed by ZooKeeper, which maintains the state of the cluster, including brokers, topics and users. Producers publish records to the leader broker for a particular topic, using a producer API, and consumers retrieve those records using a consumer API. A Kafka topic is a category, or feed name to which records are published, and they're always multi‑subscriber. A topic is broken down into partitions, in which a partition is an ordered immutable sequence of records that is continually upended to. The records and the partition are assigned a sequential ID number called the Offset that uniquely identifies each record in the partition. All of this is to say that a topic provides a published subscribe semantic that we can use for messaging, but the underlying implementation is highly scalable and supports concurrent handling of records by multiple consumers. So let's review Kafka support for inbound and outbound channel adapters.

### Apache Kafka Channel Adapters

In this section, we're going to review Kafka's support for inbound and outbound channel adapters. Let's begin by looking at how to publish a message to Kafka and how to receive it. The inbound channel adapter we're going to use is the KafkaMessageSource. We'll create it as a being and configure it to listen on a specific topic, and then annotate it with the inbound channel adapter, so that when it receives messages, it publishes them to a specific channel. Next, the outbound channel adapter we're going to use is the KafkaProducerMessageHandler. We're going to configure it with the KafkaTemplate that uses a ProducerFactory, and set the topic and key to which we want to publish it. Then we'll configure a service activater so that when a message is published to a specific channel, the KafkaProducerMessageHandler will send the message to Kafka. Creating an inbound channel adapter for Kafka is pretty straightforward. We define a channel that we'll listen on, and then create a KafkaMessageSource being annotated with the InboundChannelAdapter annotation that publishes messages to that channel as messages are received. We configure a poller to check for new messages every 1 second. The KafkaMessageSource is created with a ConsumerFactory that Spring integration will create for us when it sees the Spring Kafka libraries in our class path, and a ConsumerProperties object that specifies the topic we want to listen on and a GroupId. The Kafka consumer API defines both a low‑level consumer, as well as a high‑level abstraction called consumer groups. In this example, we'll only have one consumer, so the GroupId doesn't mean much, but if we had multiple consumers, all of the consumers in the same group would process the same set of messages concurrently. the outbound channel adapter is a little bit more complex. We first create a ProducerFactory that specifies the address of the broker we're connecting to and defines how to serialize keys and values. In this case, we serialize both of them to strings. Next we create a KafkaTemplate that our publisher will use to send messages to Kafka. It uses the ProducerFactory configuration. Finally, we create a KafkaProducerMessageHandler that uses the KafkaTemplate we just created. We specify the name of the topic we want to publish to, as well as a message key. The value is the message body, which we're going to send as a JSON string, and the key specifies the partition in the topic to which we publish the message. You are required to tell Kafka the partition that you want to publish the message to. In this case, we simply specify a reservation key, but if you're publishing a large number of messages, then you'll want to publish messages to different partitions, so that Kafka can balance its load. The example for this section is another reservation integration. In this case, the baz reservation system is publishing its reservations to Kafka. Thebaz reservation service will publish a baz reservation to Kafka using a KafkaProducerMessageHandler, which will be sent to a reservation topic by the Kafka broker. The baz reservation listener will receive the reservation using a KafkaMessageSource. Running Kafka in a Docker container is a little bit more work this time because Kafka relies on Zookeeper to manage its brokers, topics, and users. Furthermore, many of the Docker images are configured to run multiple brokers and restrict access to other Docker containers running in the same environment. The wurstmeister/kafka image provides a single broker configuration that we can access from our local computer. In order to run this, you need to download the docker‑compose‑single‑broker.yml file, which you can get by cloning its Git repository. Once you have that, you can start it using docker‑compose, which is a tool included with Docker that allows you to configure multiple containers, create relationships between them, and so forth. To start both Kafka and Zookeeper from this docker‑compose file, execute the following command, docker‑compose ‑f to specify the file, which in this case is docker‑compose‑single‑broker.yml, then the command up to start all containers in the specified YAML file, and the ‑d parameter to start them in a daemon mode as background processes. Afterwards, you can run docker ps to list all running containers to make sure that both started properly. I've occasionally seeing the Kafka container die, probably related to connecting to Zookeeper. So if that happens, you just need to run the command again. It won't start a new Zookeeper, it will start whichever containers in the YAML file are not running, namely Kafka. Let's look at the code and see this in action. We'll be building two applications this time. First, the baz reservation publisher will be publishing baz reservations to Kafka, and then the Kafka Globomantics reservation service will receive those reservations and log them.

### Apache Kafka Channel Adapters Code Example

Let's start with the reservation publisher. The KafkaOutboundConfig class is a Spring configuration class. We start by defining the broker we're going to connect to, which is the local machine on port 9092. We create two channels, the reservationChannel is the channel to which the BazReservationService will publish reservations, which is handled by an objectToJsonTransformer, and the publishReservationToKafka is the channel that publishes the messages to Kafka. The handler method creates a being that's invoked by a ServiceActivater when a message is published to the publishReservationToKafka channel. The KafkaProducerMessageHandler is created with a KafkaTemplate that is configured with a ProducerFactory. The default KafkaProducerFactory is configured with three producer config properties. The BOOTSTRAP_SERVERS_CONFIG specifies the brokerAddress to connect to. The KEY_SERIALIZER_CLASS_CONFIG defines the class name that performs the serialization of the message key, which is the partition name. And finally, the VALUE_SERIALIZER_CLASS_CONFIG defines the class name that performs the serialization of the message value, which is the message payload. For both of these, we use the StringSerializer because we're going to send a JSON string as the message body and a string as the key. With the KafkaTemplate created, we create a KafkaProducerMessageHandler and specify two properties. The TopicExpression sets the name of the topic we want to publish to, and the MessageKeyExpression sets the partition name in that topic. All of this is to say that this message handler will publish its messages to the reservation key partition in the ReservationTopic. Next, we create a messaging gateway named BazReservationGateway that publishes a BazReservation to the reservationChannel when it's published ReservationMethod is called. The BazReservation is a plain old Java object that manages an id and a name field. The BazReservation service is a Spring service with the BazReservationGateway wired into it that publishes a BazReservation to the reservationChannel through the Gateway when it's PublishedReservation method is called. Finally, the BazReservationPublisher application is a Spring boot command line application with the BazReservationService wired into it that publishes 6 reservations through the service, all with a 2 second delay between posts. Now let's look at the receiving end. The KafkaInboundConfig defines a reservationFromKafka Channel and a Kafka message source annotated with the InboundChannelAdapter annotation. This annotation defines the channel to publish messages to, namely the ReservationFromKafka channel, and defines a poller that polls the message source every 1 second for new messages. We create a new KafkaMessageSource using a ConsumerFactory that Spring will automatically create for us when it sees the Spring Kafka libraries in the class path and a ConsumerProperties, which specifies the name of the topic we want to poll and the groupId. Recall that all consumers with the same groupId will consume messages together, but in this case, we only have one consumer, but regardless, we're required to specify the groupId, so we set it to ReservationGroup. The BazReservationListener is a Spring service with a ServiceActivater that handles messages published to the reservationFromKafka channel. We received the message as a JSON string, use a Jackson ObjectMapper to convert it to an object, and then log it. Finally, the KafkaExampleApplication just starts the listener as the Spring boot application loads the beings from the configuration class. Let's run both applications and review the logs. In the BazReservationPublisher application, we can see that the BazReservationService publishes 6 reservations, and in the KafkaExampleApplication, we see that the BazReservationListener receives the 6 reservations.

### Apache Kafka Gateways

Now let's look at how to set up inbound and outbound gateways for Kafka. Kafka, inbound gateways are implemented in Spring integration using the KafkaInboundGateway class. You define a KafkaInboundGateway with a RequestChannel that handles the message and a ReplyChannel. Kafka Outbound Gateways are implemented using the KafkaProducerMessageHandler, which we saw in the last section. The difference is that instead of using a KafkaTemplate, we're going to use a ReplyingKafkaTemplate. To create an inbound gateway, we're going to create a KafkaTemplate exactly as we did when creating the outbound channel adapter, which I don't show in the slide, but we'll look at it when we review the code. Next, we create a KafkaMessageListenerContainer that listens on the addressTopic and sets the GroupId to addressGroup. Again, the GroupId is used by consumers that want to handle the same set of messages. Finally, we create the KafkaInboundGateway with the KafkaMessageListenerContainer and the KafkaTemplate wired into it. The KafkaTemplate is used to send a response back to the caller, so we set its DefaultTopic to our ReplyTopic. Then we create a new KafkaInboundGateway, passing it the container and the template, and then we set the RequestChannel that will handle the incoming message, and the ReplyChannel, to which it will publish its reply. We add a 30 second timeout so that if the handler does not reply in 30 seconds, we'll abandon the transaction. The outbound gateway is a little more complicated, so I broke it into three slides. First, the KafkaMessageListenerContainer receives a ConsumerFactory that Spring creates for us when it sees Kafka in our class path and listens for messages on the ReplyChannel. This will handle the response that we received from the inbound gateway. Next, the ReplyingKafkaTemplate is similar to the KafkaTemplate, but it uses the KafkaMessageListenerContainer for a reply once it sends its message. The ProducerFactory, which isn't shown, defines the broker address to connect to, as well as the key and value serializers that we've seen previously. Finally, the KafkaProducerMessageHandler is the being that sends messages to Kafka and awaits a reply. It creates a new KafkaProducerMessageHandler that uses the ReplyingKafkaTemplate and sets the topic and the MessageKey, which again is the partition in the topic to which to publish the message. The example for this section is the same as we've seen in the other sections. The ReservationListener receives a reservation, but needs the user's address to complete the reservation. In this case, it uses a KafkaProducerMessageHandler with a ReplyingKafkaTemplate to publish a message to the Kafka broker, which will be routed to the addressTopic. The KafkaInboundGateway will receive the message, invoke the address service through its RequestChannel, and published the response back to Kafka. The response will be received by the ReplyingKafkaTemplate and delivered back to the bazReservationListener. Let's look at the code and see this in action. Let's start with the KafkaOutboundGateway config, which defines the components we need to send an address request back to the baz reservation publisher. First we create a new channel to which will publish our address requests, and then we create a KafkaMessageListenerContainer. This container is responsible for listening for the response from the inbound gateway. We specify that it should listen for requests from the addressReplyTopic, and we set its GroupId to addressGroup. We create a ProducerFactory that specifies the broker address we want to connect to, as well as we define that we want to use string serializers to serialize both message keys and values. Next we create a ReplyingKafkaTemplate, which is used to send a message to Kafka, and wait for a response. it uses the ProducerFactory that we created to connect to the broker, and it uses the container to listen on the ReplyTopic. Then we create a KafkaProducerMessageHandler that sends messages to Kafka. Because we use the replaying KafkaTemplate, it will wait for a response and return that to it's caller. We configure that we want to publish our messages to the address key partition in the addressTopic. Finally, we create a messaging gateway that publishes messages to the bazAddressChannel, which will be directed to our KafkaProducerMessageHandler. We update the bazReservationListener to wire in the addressGateway, and then request the address with the reservation's Id and log it. Looking now at the inbound gateway, the bazAddressConfig creates an addressChannel, to which address requests will be published, and an addressReplyChannel, to which replies will be sent. We create a new ProducerFactory that connects to the specified broker address and uses the string serializer for keys and values. And then we create a KafkaTemplate that uses that ProducerFactory. We create a KafkaMessageListenerContainer and configure it to listen to the addressTopic, and then we create a KafkaInboundGateway that uses the KafkaMessageListenerChannel to receive messages, and the KafkaTemplate to send the reply. We set the RequestChannel, which will deliver messages to the address service and the ReplyChannel. We set a 30 second timeout for the RequestChannel to complete. Finally, the address service is a Spring service with a ServiceActivater that listens for messages on the addressChannel and simply returns this as my address. So let's run our applications and review the logs. In the bazReservationPublisherApplicationLogs, we can see that we published 6 reservations and that we receive requests for addresses for each user. And in the KafkaExampleApplicationLogs, we can see that we receive 6 reservations, and then we receive. this is my address responses to our address lookup calls. In this section, we reviewed how Spring integration works with Apache Kafka. We saw how the Kafka message source was used in the role of an inbound channel adapter, and the KafkaInboundGateway provided inbound gateway support. Then we saw that the KafkaProducerMessageHandler served the role of both the outbound channel adapter and the outbound gateway, with the difference being the type of KafkaTemplate that's used, a standard KafkaTemplate in the case of an outbound channel adapter and a ReplyingKafkaTemplate in the case of an outbound gateway. Next up, we're going to wrap up this module and review what we learned.

### Conclusion

In this module, we reviewed how Spring integration works with Apache Kafka. First, we saw that Apache Kafka is a publish‑subscribe based durable distributed streaming platform. It was designed to support massive scale streaming to be able to handle things like page clicks on massive websites, and it makes a wonderful message broker. We saw how the KafkaMessageSource was used in the role of an inbound channel adapter, and the KafkaProducerMessageHandler served the role of an outbound channel adapter. We saw that the KafkaInboundGateway provided inbound gateway support, and the KafkaProducerMessageHandler served the role of the outbound gateway. The KafkaProducerMessageHandler supports outbound channel adapters and outbound gateways, with the difference being the type of Kafka template that's used, a standard Kafka template in the case of an outbound channel adapter and a replying Kafka template in the case of an outbound gateway. At this point, you should understand what Apache Kafka is and what it does. You should understand how to integrate Apache Kafka was Spring integration applications using both inbound and outbound channel adapters and inbound and outbound gateways. And most importantly, you should feel comfortable integrating Apache Kafka into your own Spring integration applications. Next up, we're going to review how to integrate databases into our Spring integration applications.

# Integrating with Databases

### Introduction

In this module, we're going to review how to integrate Spring Integration applications with databases. We'll begin with an overview of database integrations to see the common patterns between our integrations. Then we'll review how to integrate with two specific databases, MariaDB, which will show us how to integrate with JDBC‑based databases, and MongoDB, which will show us how to integrate with a NoSQL database. When we create JDBC and MongoDB channel adapters, we're going to notice something similar. First, our inbound channel adapters are going to be annotated with the inbound channel adaptor annotation, and we're going to create and configure a message source with a poller that checks for new database records on a fixed interval and publishes the records to a channel. And then, when we create an outbound channel adaptor, we're going to create a MessageHandler bean that's annotated with a service activator. When it receives a message, then it will write it to the database. Putting this into a diagram, we see a message source with a poller that queries the database and publishes the records it finds to a channel that's delivered to a consumer. On the other side, we see a publisher that sends a message to a channel that's received by a service activator that invokes a message handler. The message handler then writes the record it receives to the database. So let's get started and look at using Spring Integration with a relational database using JDBC.

### MariaDB Channel Adapters

In this section, we're going to use Spring integration to connect to MariaDB using the JDBC API. MariaDB is a fork of MySQL that is intended to remain free and open‑source software under the new general public license. It was forked due to concerns of the acquisition of MySQL by Oracle and is a drop in replacement for MySQL and it's a APIs. Because of its license and compatibility with MySQL, many companies have opted to use MariaDB instead of MySQL. Regardless, we can use MariaDB to learn how to integrate with a relational database using the JDBC APIs. In order to query MariaDB for new rows matching specific criteria, we're going to use the JdbcPollingChannelAdapter. The JdbcPollingChannelAdapter is a message source that we'll configure with an InboundChannelAdapter annotation to query MariaDB for a set of rows, and then publish those rows to a channel. When we want to write a record to MariaDB, we'll use a JdbcMessageHandler annotated with a ServiceActivater and define an INSERT SQL statement used to write a row to MariaDB. Let's look at how to create a JDBC InboundChannelAdapter. First we create an InboundChannelAdapter with a 1 second poller that publishes messages to the newReservationListChannel. We create a JdbcPollingChannelAdapter, specifying a select statement that is executed every time the poller invokes the message source. In this case, we select all rows from the reservation table that have a status value of 0. Then we define a RowMapper that receives a JDBC results set and returns a new reservation object. Finally, we define an update statement to execute after the select statement finishes. This step is optional, but if we don't update the reservation status, then we'll receive all matching rows every 1 second. So we set the status value to 1 for all rows that match the IDs returned by the initial select statement. The JdbcPollingChannelAdapter returns matching rows as a list of reservations, so we define a splitter that returns the payload as a list of reservations. Recall that the splitter will create new messages for each record in the list. In this way, we'll receive one message for each reservation. Turning our attention to the OutboundChannelAdapter, we create a new message handler with a ServiceActivater that receives messages from an inputChannel. We create a JdbcMessageHandler instance, passing it an INSERT SQL statement that inserts values into the reservation table. Under the hood, the JdbcMessageHandler is going to create a prepared statement, and its setPreparedStatementSetter method will be called with a prepared statement instance and the message it wants to insert. We retrieve the message payload, cast it to a reservation, and then set the Id and name properties. For our example, consider another reservation system that doesn't send messages, but rather inserts rows into its reservation database. On the inbound side, we'll create a JdbcPollingChannelAdapter with a 1 second poller that retrieves the reservations and publishes them to a channel. As you saw, we're going to create a splitter that publishes one reservation at a time to a reservation channel that will be received and processed by a reservation listener. On the outbound side, we're going to define a reservation service that, when it's invoked, publishes a reservation message to a channel that will be received by a JdbcMessageHandler that will write it to our database. The Docker image that we're going to use for this example is the latest version of MariaDB, which has over 10 million downloads. You can start it with the Docker run command, docker run ‑d to run it as a daemon process, ‑p to specify that we want to expose port 3306 on the container, as port 3306 on the local machine, ‑e to set the environment variable MySQL_ROOT_PASSWORD= password, which, as its name implies, is the root password for the MariaDB instance to password, and finally mariadb, which is the name of the image. Next, we need to create the reservation DB database in MariaDB. You can either create a terminal session into the container and run the MySQL command, or you can execute it all in one statement. First, you need to run the Docker PS command to find the ID of the MariaDB container, and then you can run the Docker exec command, docker exec, and then the container‑id, and then the command, mysql ‑u to specify the username of root, ‑ p with the password of password, and then ‑e, and the command to execute, create database reservationdb. From here, the sample code has a schema SQL file that will create the reservation table for us. Let's dive into the code and see this in action. We'll begin by building our application. We'll start by reviewing the configuration, both the Spring configuration and the schema SQL file. Then we'll build our InboundChannelAdapter and reservation listener service, and then we'll build our OutboundChannelAdapter and reservation service. We'll run the application to write reservations to MariaDB, and then read those reservations from MariaDB.

### MariaDB Channel Adapters Code Example

The application.properties file configures our datasource. We specify the datasource.url, the username, and the password. Then, we define the driver‑class, which in this case is the mariadb.jdbc.Driver. Finally, we set the initialization mode to always so that Spring will read our schema.sql file and execute it. The schema.sql file creates the reservation table if it does not exist, and then deletes all rows from the reservation table. We do this just to clean up any data that may be lingering around from a previous run. The JdbcInboundConfig is a Spring configuration file that creates two channels. The newReservationChannel is the channel to which individual reservations will be published, and the newReservationListChannel is the channel to which the results of our query will be published as a list. We define a MessageSource Bean with an InboundChannelAdapter that publishes messages to the newReservationListChannel and has a poller that triggers the MessageSource every 1 second. Inside the method, we created a JdbcPollingChannelAdapter, passing it a dataSource that Spring automatically creates for us, and the SELECT statement to execute every time it's invoked by the poller. In this case, we select all rows from the reservation table with a status value of 0. Because this query will return a JDBC result set, we define a RowMapper that receives the result set in the index of the row in the list and returns a new reservation with the values in the result set. Finally, we set the JdbcPollingChannelAdapter's UpdateSql property with a SQL statement to execute after the SELECT has completed. We update all rows in the reservation table with the IDs returned in the SELECT statement, setting the status to 1. This is an optional step, but if we don't do it, then we'll process those rows again. The JdbcPollingChannelAdapter will return a list of reservations, so we publish that to a newReservationListChannel, which is handled by a splitter. Recall that a splitter is responsible for receiving one message and returning multiple messages. We extract the message payload, which is a list of reservations, and return that list of reservations. The splitter will create new messages with those reservations as the message payload and publish them to the newReservationChannel. This way, the ReservationListener class, which will be listening on the newReservationChannel, will receive one message for each reservation in the list. A reservation is a plain old Java object that manages id and name properties. The ReservationListener is a Spring service with a ServiceActivator that listens for messages on the newReservationChannel. They handle Reservation method, receives a reservation, and logs it. Now let's look at how to write data to MariaDB using an outbound channel adaptor. The JdbcOutboundConfig is a Spring configuration class. We create a new DirectChannel named createReservationChannel, and then a message handler with a ServiceActivator that listens for messages on the createReservationChannel. For this implementation, we created JdbcMessageHandler, passing it a data source that Spring creates for us using the dataSource properties in our application.properties file when it sees the MySQL JDBC connector in our class path. We also pass the INSERT SQL statement that we want to execute when a message arrives on the createReservationChannel to the jdbcMessageHandler constructor. Because the message will contain a reservation and the jdbcMessageHandler will create a prepared statement to execute the INSERT statement, we set its PreparedStatementSetter to translate a Reservations field to the prepared statement. The setPreparedStatementSetter method accepts a message PreparedStatementSetter, which we can implement with the lambda expression that accepts a PreparedStatement instance. We extract the Payload of the action, casting it to a Reservation. Then we set the two values called out in the INSERT statement. The first is the reservation ID, and the second is the reservation name. Finally, we create a MessagingGateway named CreateReservationGateway that publishes messages to the createReservationChannel when its createReservation method is called with a reservation. The ReservationService is a Spring service with a CreateReservationGateway wired into it that publishes a reservation to the createReservationChannel through the gateway when its createReservation method is called. Finally, the JdbcExampleApplication is a command‑line Spring boot application with the ReservationService wired into it that creates five reservations and publishes them to the ReservationService with a 1‑second delay. Let's run the code and review the logs. From the logs, we can see the ReservationService publishing each reservation, and we can see the ReservationListener receiving each reservation. In this section, we learned how to integrate databases into Spring integration application using its JDBC support. We saw that the JdbcPollingChannelAdapter fills the role of an InboundChannelAdapter. It executes a query using a poller and publishes the results of that query to a message channel. The JdbcMessageHandler fills the role of an OutboundChannelAdapter. It receives a message through a ServiceActivator and executes a SQL statement with the contents of the message. In the next section, we're going to review how to integrate MongoDB into our Spring integration applications.

### MongoDB Channel Adapters and Gateways

In this section, we're going to review how to integrate MongoDB into a Spring integration application. MongoDB is an open source, document‑based, distributed database built for modern developers and for the cloud era. It is open source, and you can use it for free. It's document‑based, meaning that it does not manage relational entities like a SQL database does. Instead, it manages JSON‑like objects that are stored in a binary form for performance. It's distributed, meaning that you can run it on a single machine or across a cluster of dozens of machines, and it's built for the cloud era to support cloud scale amounts of data. In this section, we're going to look at inbound and outbound channel adapters and outbound gateways for MongoDB. To query MongoDB and publish the results to a message channel, we're going to use the MongoDB message source class annotated with an inbound channel adapter annotation and using a poller. To write data to MongoDB, we're going to use the MongoDbStoringMessageHandler with a service activator that receives the message and passes it to the message handler to write to the database. And finally, we're going to use the MongoDbOutboundGateway to execute a query and publish the results to a channel. Let's review how to create an inbound channel adapter for MongoDB. First, we create a new message source annotated with the InboundChannelAdapter annotation that publishes messages to the reservationListFromMongoChannel and defines a poller that queries for new records every 3 seconds. The mongoMessageSource method is passed a MongoTemplate that Spring automatically creates for us when it sees the MongoDB libraries in our class path. We pass that MongoTemplate to the constructor of a MongoDbMessageSource, along with the matching query that we want to execute. MongoDB queries are that simple; return all records with a status attribute set to None. Then we set the collection name. MongoDB organizes its data into collections similar to SQL tables, so in this case, we want to retrieve records from the reservations collection. Finally, we set the Entity class to the class we want to deserialize the results into, which will be the Reservation class in this example. Just like with our JDBC example, the MongoDB messageSource publishes the results of its query as a list of records, which, in this case, are reservations. So we create a splitter that receives the message and splits the list into individual reservation objects and publishes them to the reservationFromMongoChannel. Creating an Outbound Channel Adapter is pretty easy. We create a new message handler with a ServiceActivator that listens for messages on the toMongoChannel. We create a MongoDbStoringMessageHandler, passing it the Mongo template that Spring creates for us, and we set the collection name to the reservations collection. The outbound gateway is a little more work. We create a message handler with a ServiceActivator that listens for messages on the getReservationChannel. We create a MongoDbOutboundGateway, passing it the MongoTemplate that, again, Spring creates for us, and we specify the name of the collection that we want to query. The QueryExpressionString is where we can extract data from the message to build our query. In this case, we set it to the entire message payload, which gives us the flexibility to execute any query that we want. In this case, we set the ExpectSingleResult to true; otherwise, a response will be wrapped in a list of matching records. We specify that we want to deserialize the record into a Reservation instance, and then we set the utput channel to which to send our response. We create a messaging gateway that will invoke our outbound gateway by publishing messages to the getReservationChannel and listening for the reply on the getReservationReplyChannel. The query method accepts the query string to execute and returns a single reservation. For this example, we're going to define a reservation service that publishes reservations to MongoDB using a MongoDbStoringMessageHandler. A MongoDB message source will be configured with a poller querying MongoDB every 3 seconds, and when it finds a reservation with a status of none, it will publish those reservations to a reservation listener. A step that's not shown here is that we're going to make an additional call to update the status to processed, and then the reservation listener will use the Query Reservation Gateway to retrieve the updated reservation. It will send a request to the MongoDB Outbound Gateway, which will execute the query and publish the results to a reply channel that will then be delivered back to the reservation listener. So to summarize this workflow, the reservation service writes a reservation to MongoDB. That reservation is sent to the reservation listener that marks the reservation as processed and then retrieves the updated reservation back from MongoDB. The official Docker image from MongoDB is simply mongo. It has over 10 million downloads and is the official image maintained by the Docker community. I encourage you to visit the DockerHub page to review the different configurations, but to run a simple MongoDB container, execute docker run ‑d for daemon mode, ‑p to expose port 27017 on the container to port 27017 on the local host, and mongo as the container name. Note that this container will be ephemeral, meaning that if you restart it, you'll lose all of your data. You can store your data locally using the ‑v command‑line argument to map a local path to the container/data/db folder, which is explained on the DockerHub page. So let's dive into the code and see this in action. We'll start by creating our application components. Our inbound channel adapter that reads data from MongoDB, our outbound channel adapter that writes data to MongoDB, and our outbound gateway that queries MongoDB. We'll execute the code and validate that records are written to and read from MongoDB.

### MongoDB Channel Adapters and Gateways Code Example

The OutboundChannelAdapterConfig is a Spring configuration class that defines two channels. The reservationToMongoChannel is the channel that we'll use to write data to Mongo, and the updateReservationChannel is the channel that we'll use to update a reservation status to processed. For the first case, we define a message handler with a service activator that listens for messages on the reservationToMongoChannel. We create a new MongoDbStoringMessageHandler, passing it a Mongo template that Spring creates for us when it sees the Mongo libraries in our class path, and then we set the collection name to reservations. It expects an expression, so because we want to pass a literal value, we wrap reservations with a literal expression. We create a messaging gateway that publishes messages to the reservationToMongoChannel when its publishReservation method is called. This is all we need to do in order to write a reservation to the MongoDB's reservations collection. For the second case, we use a different strategy, one that we'll look at further when building custom channel adapters later in the course. We create a message handler with a service activator that listens for messages on the update reservation channel. Rather than use a pre‑built message handler, we implement our own. A message handler is a functional interface that defines one method, handleMessage. Because it's a functional interface, we can implement it using a lambda expression. The expression we write is as follows: when we receive a message, we extract its payload as a reservation, query for the reservations that matched the specified query and then execute an update. The Mongo template has a pretty simple mechanism for defining both the query as well as the update. We create a new query instance and add a criteria to it. In this case, we add a criteria where the id property of the record is equal to the reservation's id. This should match only one record. Then we create an Update instance and set the fields that we want to change. In this case, we want to update the name and the status with the values and the reservation. Finally, we use the Mongo template by executing its updateFirst method, passing it the query, the update and the entity class that we're updating, namely our reservation. Other than seeing how to update a record in MongoDB, the bigger thing to observe in this example is that we can create a message handler with a lambda expression and do whatever we'd like to do with the message. Finally, we create a messaging gateway that publishes messages to the updateReservationChannel when it's updateReservation method is called. A reservation is a plain old Java object that manages three fields, an id, a name and a status. Notice that the id is of type ObjectId, which is the MongoDB type that represents keys in its documents. The reservation class is annotated with MongoDB's document annotation, which means that it represents a document or record in MongoDB, and it specifies that the reservation class represents a document in the reservations collection. The reservation service is a Spring service with the MongoReservationGateway wired into it that publishes a reservation through the gateway when its publishReservation method is called. At this point, we're able to insert a reservation into MongoDB, so let's review how we're going to retrieve it. The InboundChannelAdapterConfig is a Spring configuration file that defines two channels. The reservationFromMongoChannel is the channel to which individual reservations will be published, and the reservationListFromMongoChannel is the channel to which a list of reservations loaded by our query will be published. The mongoMessageSource method creates a message source bean with an InboundChannelAdapter annotation that publishes messages to the reservationListFromMongoChannel and defines a poller that invokes the bean to execute the query every three seconds. Inside the method, we create a MongoDbMessageSource instance, passing it the Mongo template that Spring creates for us and the query as a literal expression. The query itself is searching for all documents in the reservations collection with a status property value of none. We define the collection name on the next line as reservations, and then we set the entity class to which to deserialize the response to the reservation class. Finally, we may receive multiple documents from MongoDB, so we publish the list of reservation documents to a splitter that extracts the payload and returns the list of reservations. The splitter will then publish each individual reservation to the reservationFromMongoChannel. All of this is to say that every three seconds, we execute the status' none query publish, the list of results to a splitter that then sends each individual reservation to the reservationFromMongoChannel. The reservation listener is a Spring service that defines a handleReservation method annotated with the ServiceActivator annotation that listens for messages on the reservationFromMongoChannel. It has two gateways wired into it. The UpdateReservationGateway is used to publish an updated reservation to the updateReservationChannel, which will be handled by the message handler that we created to update a document in MongoDB, and the QueryReservationGateway, which is used to retrieve the final updated reservation using a MongoDB outbound gateway, which we'll see in a minute. The handleReservation method logs the reservation, then sets its status to processed and updates the status of the reservation in MongoDB by sending it to the UpdateReservationGateway, and finally, it uses the QueryReservationGateway to retrieve the final processed version of the reservation. The QueryReservationGateway defines a query method to which we can pass a query, so we specify that we want the document with the id that matches our reservation id. Let's look at how the MongoDbOutboundGateway works. The OutboundGatewayConfig is a Spring configuration class. It defines two channels, the getReservationChannel is the channel to which we'll publish a query for our query, and the getRreservationReplyChannel is the channel to which the MongoDbOutboundGateway will publish its reply. The MongoDbOutboundGateway method creates a message handler bean with a service activator that listens for messages published to the getReservationChannel. We create a MongoDbOutboundGateway instance, passing it a Mongo template. We specify the collection name as reservations, and then we set a query expression string. This uses the Spring expression language, which in this case, we specify that we want it to use the full payload for the query. We specify that we expect a single result and that we want to deserialize the document into a reservation class, and finally, we specify that we want it to publish its result to the outbound channel named getReservationReply. We create a QueryReservationGateway that publishes messages to the getReservationChannel and listens for a reply on the getReservationReplyChannel. The query method accepts a string that contains the MongoDB query and returns a reservation. The MongoDbExampleApplication class is a Spring Boot command line application with a reservation service wired into it that creates six reservations and publishes them to the reservation service. So let's run the code and review the logs. We can see that the reservation service publishes a reservation, which has an id of null. Then we see the reservation listener receives the reservation with a populated id, and then we see that the reservation listener receives its final reservation with a status of processed. In this section, we reviewed integrating MongoDB into a Spring Integration application. First, we saw how the MongoDbMessageSource served the role of an inbound channel adapter. We configured it with an InboundChannelAdapter annotation and a poller to invoke it every three seconds. It executes a query and publishes the results to a splitter that ultimately publishes individual reservations to the reservation listener. Then we saw how the MongoDbStoringMessageHandler served the role of an outbound channel adapter. We created it with a service activator that receives a reservation and writes it to MongoDB. Finally, we saw how the MongoDbOutboundGateway served the role of an outbound gateway. It executes a query and publishes the results to a reply channel. In the next section, we'll wrap up this module and review what we learned.

### Conclusion

In this section, we're going to review what we learned. We reviewed how to integrate with two databases. MariaDB, which uses JDBC. What you learned here should be applicable to any relational database that supports JDBC, such as Oracle, SQL Server, and MySQL. And MongoDB, which is a document‑oriented NoSQL database. We saw commonalities between how databases implement Inbound and OutboundChannelAdapters. For InboundChannelAdapters, we saw that we create a message source with a poller that queries the database and publishes the results of that query to a message channel. And for OutboundChannelAdapters, we saw that we create a message handler with a service activater that receives a message and writes it to a database. At this point, you should understand how to integrate with databases using JDBC, you should understand how to integrate with MongoDB, and more importantly, you should understand the Spring integration model for integrating with databases. In the next module, we're going to review how to integrate with RESTful Web Services.

# Integrating with Web Services

### Introduction

Welcome to the module, Integrating with RESTful Web Services, in the Spring Integration: Using Channel Adapters to Integrate with External Systems course. In this module, we're going to review how to integrate our Spring Integration applications with RESTful web services. We'll begin with an overview of RESTful web services to understand how they work and our strategy for integrating with them. Then we'll dive into how we can use HTTP outbound channel adapters and gateways to invoke a RESTful web service and receive a response. Representational state transfer, or REST, is an architectural pattern, based on HTTP, used for creating web services. It's not a specification for how to format and send your messages, but rather it's an architectural pattern that builds on the successes of the HTTP protocol. It was originally introduced in 2000 by Roy Fielding in his doctoral dissertation and has garnered an immense amount of support over the past decade. Now my goal is not to give you a history lesson about REST, but instead a brief understanding about how it works so that we can effectively integrate with RESTful web services. RESTful web services operate on entities called resources using the HTTP protocol and different HTTP methods or verbs. Now you may not see all of these in the services with which you're integrating, but it's good to understand what they are and what they're used for. When working with RESTful web services, we operate on resources which are defined by an HTTP URI. We use the GET verb to retrieve a resource, the POST verb to create a new resource, the PUT verb to update an existing resource, the DELETE verb to remove a resource, and the lesser‑used PATCH verb to partially update an existing resource. All of this is to say that we interact with RESTful web services by making standard HTTP calls. REST defines the protocol, namely HTTP, but does not define the format for its resources. The most popular format that you'll find on the web is JavaScript Object Notation, or JSON. The next most popular is XML. Again, REST does not care what format you use, but if you use JSON or XML, Spring Integration has built‑in support for both of them. Before we get into the code, I want to share the capabilities of Spring Integration support for RESTful web services, as well as the scope of this module. Spring Integration provides support for inbound and outbound channel adapters, as well as gateways. Inbound channel adapters allow you to expose a RESTful web service that, when invoked, will create a message that you can handle with all of the Spring Integration capabilities that you've seen in this series of courses. Outbound channel adapters allow you to invoke a RESTful web service, and outbound gateways allow you to invoke a RESTful web service and receive a response. For this module, we're going to focus on the last two, namely outbound channel adapters and outbound gateways. In practice, most Spring Integration applications will receive their messages from a message broker. But it's very common for a Spring Integration workflow to retrieve additional information from a RESTful web service or for a workload to complete by sending the message to a RESTful web service. So let's get started by reviewing how to use HTTP outbound channel adapters and gateways.

### HTTP Outbound Channel Adapters and Gateways

In this section, we're going to review how to use Spring Integration's HTTP outbound channel adapters and gateways to execute RESTful web service calls. We're fortunate because HTTP outbound channel adapters and outbound gateways are implemented by the same class. The HTTP outbound channel adaptor is implemented by the HttpRequestExecuting message handler with an expectReply value set to false, and the HTTP outbound gateway is implemented by the HttpRequestExecuting message handler with an expectReply value set to true. As we've seen with other outbound components, this is a message handler. So we'll be annotating our bean with a service activator that invokes it when a message arrives on a specified channel. Creating an outbound channel adapter is pretty straightforward. We create a message handler bean annotated with a ServiceActivator listening on a specified input channel. We create an HttpRequestExecuting MessageHandler, passing it the URL of a RESTful resource. Then we define the HTTP method or verb that we want to invoke on that service. And finally, we set the expectReply value to false. When this handler receives a message, it will extract the message's payload, serialize it to whatever value is defined in the message's content type message header, and post it to the specified URL. Creating an outbound gateway is a little more work primarily because we're using a dynamic URL with a variable that we'll need to populate from our message, and we need to handle the response from the web service. Again, we create a message handler bean annotated with a service activator that is listening on a specified channel. We create a new HttpRequestExecuting message handler, passing it the URL to the web service. In this case, we include a URI variable named id by enclosing it in braces. We specify the HTTP methods to use as the GET verb, and then we set its expectReply value to true and specify that the reply should be a reservation. Next, we create a Spring expression language parser and then map the id variable in the URL to the raw value of the message payload. When we later invoke the message handler, we'll do so with the integer ID of the reservation to retrieve. Finally, we set the name of the output channel to which the message handler should publish the response from the web service. We need something to test with, so rather than integrating with a message broker or some other message source, I decided to build a stub message source. We create a message source bean with an inbound channel adapter that publishes a list of reservations to the fromStubChannel when it's invoked by a 5‑second poller. Inside the bean definition, we implement the message source functional interface by creating a lambda expression that accepts no input and returns a message with a list of reservations as its payload. We'll talk more about building custom message sources in the next module, but this is a simple way to create a message source that returns a static set of values. Finally, because we're returning a list of reservations, we define a splitter that receives the list of reservations from the stub message source and publishes individual reservations to the reservation fromStubChannel. For our example, we're going to use our stub message source to publish reservations to the reservation listener. The reservation listener will first post the reservation to the reservation web service using an HttpRequestExecuting MessageHandler as an outbound channel adaptor and then query for the reservation using another HttpRequestExecuting MessageHandler, but this time executing a GET request and handling the response. The reservation web service is a simple Spring MVC RESTful web service using Spring data to persist reservations to an embedded H2 database. It's currently configured to listen for web requests on port 7080 so that it won't conflict with any other services that you have running on port 8080. I have the source code for this course on GitHub at github.com/geekcap‑pluralsight/channeladapters. You can clone the repository if you'd like to follow along. So let's dive into the code and see this in action. We'll begin by building our application, our stub message source, which will publish reservations to the reservation listener, our outbound channel adapter, which will be used to post reservations to the reservation web service, our outbound gateway, which will be used to retrieve a reservation from the reservation web service, and the reservation listener. Then we'll run the application and validate the results.

### HTTP Outbound Channel Adapters and Gateways Code Example

The StubInboundChannelAdapterConfig is a Spring configuration class. It defines two channels. The resevervationFromStubChannel is the channel to which individual reservations will be published, and the reservationListFromStubChannel is the channel to which a list of reservations will be published from our stub message source. The stubMessageSource method is a MessageSource bean that returns a list of reservations and is annotated by the InboundChannelAdaptor annotation, which publishes messages to the reservationListFromStubChannel and includes a 5‑second poller. The method body creates a new message source using a Lambda expression. It receives no arguments and returns a list of reservations with two hard‑coded reservations in it. The Splitter receives the list of reservations from the reservationListFromStubChannel and publishes individual reservations to the reservationFromStubChannel. A reservation is a plain old Java object that manages an ID, a name, a status, and a version number. The reservation listener is a Spring service with a service activator that listens for messages on the reservationFromStubChannel. It has two gateways wired into it that we'll review shortly. The publishReservationGateway is used to publish a reservation to the reservation web service, and the getReservationGateway is used to retrieve a reservation from the reservation web service. The handle reservation method extracts the reservation payload and logs it. It then publishes a new message with the reservation as its payload to the publishReservationGateway. One important step that we add in here is that we need to set the HTTP content type header to application/json. The HttpRequestExecutingMessageHandler, which we'll see in a minute, will automatically serialize the reservation to a JSON string, but only if we set the message's CONTENT_TYPE header to application/json. If we don't, then it will see the reservation as a serialized Java object and the whole serialization process will fail. Finally, after the published reservation method has successfully published the reservation to the reservation web service, we use the getReservationGateway to retrieve the reservation with the specified ID from the reservation web service and log it. The HttpOutboundChannelAdapterConfig is a Spring configuration class that allows us to post a reservation to the reservation web service/ It defines a toReservationServiceChannel and a MessageHandler bean with a service activator that listens for messages on that channel. We create a new HttpRequestExecutingMessageHandler, specifying the URL upon which we want to operate. If you started the reservation web service, it should be running on localhost 7080, and we're going to post a new reservation to the slash reservation resource. Speaking of which, on the next line, we set the HttpMethod to post. Finally, we set its ExpectReply value to false, because we're not going to handle the response from the web service. We create a messaging gateway named PublishedReservationGateway that publishes a message with the reservation payload to the toReservationServiceChannel. That's all we need to do to invoke a web service call. The HttpGatewayOutboundConfig is the Spring configuration class that handles the retrieval of a reservation from the reservation web service. It's a little more complicated, because we're going to include a variable in our URL, and we're going to need to handle the response from the web service. We define two channels, the getReservationChannel is the channel to which we request a reservation from the reservation web service, and the getReservationReplyChannel is the channel to which the MessageHandler will publish the response from the web service. The httpOutboundGateway method creates a MessageHandler bean and is annotated with a service activator that listens for messages published to the getReservationChannel. We create an HttpRequestExecutingMessageHandler specifying the URL of the service that we want to invoke. In this case, the URL contains a variable named reservationId, which is denoted by curly braces. We set these HTTP method to get and then we specify that we expect to reply, and that reply should be of type reservation. Next, we create a spring expression language expression, part sir, and then set the Docker variable expressions to resolve the reservation IDE to the payload of the message. Finally, we set the Output Channel, which is the channel to which the message handler should publish the response of the web service call to the getReservationReplyChannel. Finally, we create a messaging gateway named getReservationGateway that publishes messages to the getReservationChannel and listens for replies on the getReservationReplyChannel. The getReservation method accepts the IDE of a reservation to retrieve, which will become the payload of the message and is the reason that our URI variable expression resolves the message payload to the reservation ID variable and returns the reservation that it receives in the reply channel. The HTTPExampleApplication is a command line Spring Boot application. All of the action will happen in the background, so it's simply waits for 5 seconds and then exits. Let's run the application and review the logs. From the logs, we can see that the reservation listener received the reservation from the channel, and published it to the reservation web service, and then we can see that it was able to retrieve the reservation from the web service. And if we open a web browser to localhost 7080 /reservations, we can see that the reservation web service does, in fact, have both reservations.

### Conclusion

In this module, we reviewed how to integrate with RESTful Web Services. We saw that the HttpRequestExecuting MessageHandler served the role of both an outbound channel adapter, as well as an outbound gateway. The difference being the value of its expectReply property, false for an outbound channel adapter and true for an outbound gateway. We saw how to use URL variables and resolve them to values in the message payload, and we saw how to use the HttpRequestExecuting MessageHandler to receive a response as the class of our choice. So at this point, you should understand how to integrate with RESTful Web Services, and you should understand how to use different HTTP methods, URL variables, and handle HTTP responses. In the next module, we're going to review how to build custom channel adapters so that we can integrate with external systems for which Spring Integration does not provide native support.

# Integrating with Custom External Systems

### Introduction

Welcome to the final module, Integrating with Custom External Systems in the Spring Integration: Using Channel Adapters to Integrate with External Systems course. In this module, we're going to review how to build custom inbound and outbound channel adapters. We'll start by reviewing our custom integration strategy to learn how we can integrate with systems for which Spring Integration does not have native support. Then we're going to review how to build a custom inbound channel adapter, and finally, we'll review how to build a custom outbound channel adapter. As we've seen through this course, inbound and outbound channel adapters share commonalities that we can leverage to build our own custom adapters. We saw several Spring Integration native inbound channel adapters that were ultimately some form of message source, and we saw outbound channel adapters that were some form of message handler. So if we want to integrate with a custom external system, all we need to do is create our own MessageSource and MessageHandler implementations. A MessageSource is a functional interface that defines a received method that returns a message. We have three options to build a custom MessageSource. First, we can implement our functionality inside our configuration class using a lambda expression. Next, we can create a new class that implements the message source interface and override its receive method. And finally, we can extend the abstract MessageSource class and implement its doReceive method. For the example in this module, we'll opt for the final option, namely extending the abstract MessageSource class. A MessageHandler is a functional interface that defines a handleMessage method that receives a message. We have similar options to build a custom MessageHandler. We can implement a MessageHandler using a lambda expression as we saw in the Mongo DB example. We can implement the MessageHandler interface and override its handleMessage method. And finally, we can extend the abstract MessageHandler class and override its handleMessage internal method. Again, for the example in this module, we'll opt to extend the abstract MessageHandler class. Putting all of this into a diagram, a publisher will send a message to a channel that triggers a service activator that invokes our custom MessageHandler. Our custom MessageHandler will implement the logic to send the message to the external system, then we'll define a message source with an inbound channel adapter annotation that defines a poller that invokes the message source. The message source will retrieve the data from the external system, and the inbound channel adapter will publish it to a channel that will ultimately be received by a consumer. We're going to need a sample external system, but to keep things simple and to keep us focused on the Spring Integration side of things, rather than on the complexities of an external system, we're going to implement a simple directory monitor. Well read reservations as JSON files from a local directory. And when creating reservations, we'll write them to a local directory. Spring Integration already has this functionality, but it'll be a simple example that will allow us to see all of the moving parts in creating inbound and outbound channel adapters. So let's get started by reviewing how to create a custom inbound channel adapter.

### Custom Inbound and Outbound Channel Adapters

In this section, we're going to review how to create a custom inbound channel adapter. As I mentioned in the previous section, inbound channel adapters use a MessageSource, and we have three options for creating our own custom MessageSource. We can implement one using a Lambda expression in our configuration class, we can directly implement the MessageSource interface, or we can extend the AbstractMessageSource class. To build a MessageSource using a Lambda expression, we first define a MessageSource Bean with an InboundChannelAdaptor annotation that includes a poller. For the method body, we create a new Lambda expression that accepts no arguments and returns a message. In this example, you can see that we create a list of reservations, add two reservations to the list, and return the list as the payload of a message. This is the simplest way of building a MessageSource, but it isn't very reusable. The more robust way of building a MessageSource is to extend the AbstractMessageSource class, especially if we want to build a reusable component. The reason is that it provides support out of the box for Spring's lifecycle management, so classes that extend it, such as the AmqpMessageSource, JDBC polling channel adaptor, and MongoDbMessageSource that we've seen in previous modules become first‑class citizens in the Spring Integration ecosystem. To create a custom MessageSource, we create a class that extends the AbstractMessageSource class and provide an implementation of the doReceive() method. In this case, the DirectoryMonitorMessageSource extends the AbstractMessageSource class, specifying that it can manage any object. We specify that it reads an object rather than a reservation, because we're going to make it generic. When we create it, we'll specify the directory to read from and the entity class to which we want the files in that directory to be deserialized. In the doReceive() method, we list all files in the specified directory, use Jackson to deserialize them into a specific entity class, and then add them to a list of results. We then package that list of results into the payload of a message and return it back to the inbound channel adapter that invoked it. As I mentioned in the previous section, outbound channel adapters use a MessageHandler annotated with a service activator that invokes the handler whenever a message arrives on the specified channel. Again, we can implement our functionality by using a Lambda expression, by implementing the MessageHandler interface, or by extending the AbstractMessageHandler class. To build a MessageHandler using a Lambda expression, we define a MessageHandler Bean annotated with a ServiceActivator that listens on a specific channel. For the message body, we define a Lambda expression that accepts a message and performs some business logic with that message. Because it provides more robust support and is more reusable, we're going to opt to extend the AbstractMessageHandler class for our example. The DirectoryMonitorMessageHandler extends the AbstractMessageHandler class and overrides the handleMessageInternal method. The implementation is pretty simple. It generates a random UUID for a file name and serializes the message payload to that file using a Jackson objectMapper. So let's dive into the code and see this in action. We'll begin by building our application. First, we'll build our DirectoryMonitorMessageSource that will scan a directory, read files from that directory, and publish them to a channel. Then we'll build our DirectoryMonitorMessageHandler that will receive a message and write its payload to a file. We'll set up our configuration classes to use the new MessageSource and MessageHandler. And finally, we'll build our reservation listener and reservation service. Then we'll run the application and validate the results.

### Custom Inbound and Outbound Channel Adapters Code Example

Let's start by looking at the DirectoryMonitorMessageSource. We extend the AbstractMessageSource, specifying that we support any type of object. We define a Jackson ObjectMapper, which will deserialize a JSON file on the local file system to an object. We define the directory we want to monitor and the entityClass to which to deserialize the file's contents. We define a simple constructor that accepts this directory and the entityClass, as well as an empty constructor and some getter and setter methods. The doReceive method is where we implement our business logic. We create an ArrayList to hold our results. Then we create a new File object with the configure directory and call its ListFiles method. We iterate over all the files in the directory, deserialize them to the specified entityClass using a Jackson ObjectMapper, and then add them to our list of results. Finally, we use Spring Integration's MessageBuilder to construct a new message with results as its payload. To complete the class, we override the AbstractMessageSource's getComponentType method to return the string directory‑monitor:inbound‑channel‑adapter. This method is required because the AbstractMessageSource implements the name component interface and Spring will use this name in its bean management. Now that we have a MessageSource, the CustomInboundChannelAdapterConfig class will use it. We define two channels. The reservationFromCustomChannel is the channel to which individual reservations will be published and the reservationListFromCustomChannel is the channel to which our MessageSource will publish a list of reservations. The directoryMonitorMessageSource method is annotated with the InboundChannelAdapter annotation, specifying that it will publish its messages to the reservationListFromCustomChannel, and it includes a poller that invokes the bean every 5 seconds. Inside the method, we create a new DirectoryMonitorMessageSource, passing it the directory to monitor, namely the reservations directory, as well as the entityClass to which to deserialize the files in that directory, namely the Reservation.class. Finally, because the DirectoryMonitorMessageSource returns a list of reservations, we create a splitter that listens for messages on the reservationListFromCustomChannel and publishes messages to the reservationFromCustomChannel. It extracts the message payload, which is a list of reservations, and returns it to the splitter. The splitter will create new messages for each individual reservation in the list and publish them to the reservationFromCustomChannel. A reservation is a plain, old Java object that manages three fields, an id, a name, and status. The ReservationListener is a Spring service with a ServiceActivator that listens for reservations published to the reservationFromCustomChannel and logs them. Now that we know how to read messages, let's look at how we write them. The DirectoryMonitorMessageHandler extends the AbstractMessageHandler class. It creates a Jackson ObjectMapper and defines the directory to which to write objects. We override the handleMessageInternal method, which has passed the message to process. We generate a unique UUID for the file name, and then create a path object that concatenates the configure directory with the uuid .json file name. Finally, we use the Jackson ObjectMapper to write the message payload to the path's file. The CustomOutboundChannelAdapterConfig is a Spring configuration class. It defines a reservation to CustomChannel and then a customMessageHandler method with a ServiceActivator that listens for messages on that channel. We create a new instance of our DirectoryMonitorMessageHandler, specifying that it should write its messages to the reservations directory. Finally, we define a MessagingGateway named CreateReservationGateway that publishes messages to the reservationToCustomChannel when its createReservation method is invoked. The reservation service is a Spring service with the CreateReservationGateway wired into it that publishes reservations to the gateway when its createReservation method is called. Finally, the CustomAdaptersApplication is a command line Spring boot application with the ReservationService wired into it that creates six Reservations and sends them to the ReservationService every 2 seconds. Then we wait 3 seconds before exiting the application for everything to complete. Let's run the code and review the logs. From the logs, we can see the ReservationService creating reservations, and we can see the ReservationListener receiving those reservations. One thing to note is that we did not add logic to skip the messages that we've already processed, so you'll see the same messages processed multiple times. I'll leave that for you to work on if you're so inclined. Additionally, if you run the application multiple times, you'll see that it will discover your previous runs, so you might want to delete existing files before you run the application.

### Conclusion

In this section, we reviewed how to create custom inbound and outbound channel adapters. Throughout the various integrations that we built in this course, we saw that inbound channel adapters typically work with MessageSources, and outbound channel adapters typically work with MessageHandlers. And we saw that we can build a custom inbound channel adapter by extending the abstract MessageSource class and overriding its doReceive method. And we could build custom outbound channel adapters by extending the abstract MessageHandler class and overriding its handleMessage internal method. So at this point, you should understand how to build custom inbound and outbound channel adapters. Throughout this course, we reviewed several of the more popular integrations that Spring Integration provides out of the box from AMQP and JMS message brokers to Apache Kafka, to relational databases, and Mongo DB, as well as RESTful web services. Now that you understand custom inbound and outbound channel adapters, you should be prepared to integrate with any system for which Spring Integration does not provide native support, so happy coding.